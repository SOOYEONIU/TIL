# 리액트 핵심 요소 깊게 살펴보기

## JSX란?
* 보통 리액트를 통해 JSX를 접하기 때문에 JSX가 리액트의 전유물이라고 오해하는 경우가 있다. → 반은 맞고 반은 틀림

* JSX는 흔히 개발자들이 알고 있는 XML과 구조적으로 유사한 내장형 구문이며(구조적으로 비슷해보이지만 각각의 용도와 사용 환경은 다름), 리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 옳다.

* 페이스북에서 독자적으로 개발했기에 자바스크립트 표준의 일부는 아니다. 따라서 JSX가 포함된 코드는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환된다. 

* JSX의 설계 목적
    * 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는데 초점을 두고 있다.
    * 쉽게 이야기 하면, **JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해두고, 이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것이 목표라 볼 수 있다.**

### JSX의 정의
* JSX의 4가지 기본 컴포넌트 구성
    * `JSXElement`
        * JSX를 구성하는 가장 기본적인 요소, HTML의 요소(element)와 비슷한 역할을 함.
        * 형태
            * `JSXOpeningElement`, `JSXClosingElement`
                * 두 요소는 일반적인 HTML 태그와 같은 형태로 사용된다. 따라서 반드시 쌍으로 사용되어야 한다.
                * 사용 상황:
                    * 여러 자식을 포함하는 경우 : 태그 내부에 다른 태그나 텍스트를 포함하여 구조를 잡을 때 사용
                    * 상태나 props에 따라 내용이 동적으로 변할 때: 렌더될 내용을 조건에 따라 다르게 보여주고 싶을떄 사용
                ```javascript
                const MyComponent = (props) => {
                    return (
                    <div>
                    <h1>안녕하세요, {props.name}</h1>
                    <p>React JSX 예시입니다.</p>
                    </div>
                    );
                };

                export default function App() {
                    return ( 
                    <MyComponent name={"sooyeon"}>
                    </MyComponent>
                    );
                }
                ```
                * 위 예제에서 보이는 \<MyComponent>와 \</MyComponent>가 JSXOpeningElement와 JSXClosingElement로 이루어져 있다.
            * `JSXSelfClosingElement`
                * 요소가 시작되고, 스스로 종료되는 형태를 의미한다. 자식 요소가 없는 경우 사용된다.
                * 이는 HTML의 단일 태그(\<img />, \<input /> 등)와 유사하다.
            * `JSXFragment`
                * 아무런 요소가 없으며 반환되는 요소가 여러개인 경우 여러 요소를 그룹화할 때 사용된다. 
                * ReactFragment는 <React.Fragment></React.Fragment> 또는 간단한 단축 문법인 <></>를 사용하여 작성할 수 있다.
        * 이러한 요소들을 활용하여 더 유지보수 가능하고 읽기 쉬운 코드를 작성하는데 도움을 준다.

        * 리액트에서 컴포넌트를 만들어 사용할 때는 반드시 대문자로 시작하는 컴포넌트를 만들어야 사용 가능하다. 이유는 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서다.
        
        * `JSXElementName` : 요소 이름을 짓는 원칙이 있다. 그 원칙을 함께 살펴보자.
            * `JSXIdentifier` : JSX 내부에서 사용할 수 있는 식별자를 의미한다. 그리고 자바스크립트와 마찬가지로 숫자로 시작하거나 $와 _외의 다른 특수문자로는 시작할 수 없다.
                ```javascript
                <Component />
                ```
                * 장점 : 읽기 쉽고 간단하며, 대부분의 일반적인 컴포넌트 사용 사례에 적합하다.
            
            * `JSXNamespacedName`: `JSXIdentifier:JSXIdentifier`의 조합
                * 즉 :을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. :로 묶을 수 있는 것은 한 개뿐이다.
                * JSX 구문에서 네임스페이스 접두사가 있는 이름을 나타내기 위한 용어이다.
                    ```Javascript
                    <namespace:Component />
                    ```
                * JSX에서는 대부분의 네임스페이스 관련 작업이 자동으로 처리되어 개발자가 명시적으로 `JSXNamespaceName`을 명시하는 경우는 드물다.

            * `JSXMemberExperssion`: `JSXIdentifier.JSXIdentifier`의 조합
                * 즉 .을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. .는 여러 개 이어서 하는 것도 가능하다. 단, JSXNamespacedName과 이어서 사용하는 것은 불가능하다.
                    ```javascript
                    const MyComponents = {
                        DatePicker: function DataPicker(props) {
                            return <div>{props.date}</div>
                        }
                    };

                    function App() {
                        return(
                            <div>
                                <MyComponents.DatePicker date={new Date().toLocaleDateString()}>
                            </div>
                        )
                    }
                    ```
                * 위 코드에서 <MyComponents.DatePicker />는 JSXMemberExpression의 예시이다. 이 표현식은 MyComponents 객체의 DatePicker 속성을 참조한다.
                * React에서 JSXMemberExpression은 내부적으로 중요한 역할을 하지만, 개발자가 이를 다루거나 언급할 필요 없다. **React와 Babel등의 도구는 이러한 내부적인 복합성을 자동으로 처리하여 개발자가 더 생산적으로 작업할 수 있도록 돕는다.**

    * JSXAttributes
        * JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않는다.

            * JSXSpreadAttributes: 자바스크립트의 전개 연산자(스프레드 연산자)와 동일한 역할을 한다고 볼 수 있다. 따라서, 스프레드 연산자를 사용해 여러 속성을 한번에 추가할 때 사용한다. 
                * {...AssignmentExpression}: 이 AssignmentExpression에는 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있다. 여기에 조건문 표현식, 화살표 함수, 할당식 등 다양한 것이 포함되어 있다.
                * 아래의 예시로 이해를 돕는다.
                ```javascript
                import React from 'react';

                const Button = (props) => {
                    return <button {...props}>{props.label}</button>;
                }

                const App = () => {
                    const buttonProps = {
                        type: 'button',
                        onClick: () => alert('Button Clicked'),
                        style: {backgroundColor: 'blue', color: 'white'},
                        label: 'Click me',
                    }

                    return {
                        <div>
                            <h1>JSXSpreadAttributes Example</h1>
                            <Button {...buttonProps}>
                        </div>
                    }
                }

                export default App;
                ```
                이렇게 하면 각 속성을 하나씩 전달하는 대신 간편하게 한번에 전달할 수 있어서 코드가 더 깔끔해지고 유지보수하기 쉬워진다. 

            * JSXAttributeValue: 속성의 키에 할당할 수 있는 값으로, 다음 중 하나를 만족해야 한다.
                * `"큰따옴표로 구성된 문자열"`: 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
                * `'작은따옴표로 구성된 문자열'`: 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
                * `{ AssignmentExpression }`: 자바스크립트의 AssignmentExpression을 의미한다. AssignmentExpression은 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말한다. 즉, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능하다.
                * `JSXElement`: 값으로 다른 JSX 요소가 들어갈 수 있다. 리액트에선 자주 보이진 않는 코드이다.
                * \<Child attribute=\{\<div>hello\</div>\} />와 같이 값으로 들어가는 리액트 컴포넌트를 {}로 감싸는 걸 보는 것이 더 익숙할텐데, 사실 이것은 문법적 오류가 아닌 prettier의 규칙(태그가 포함된 JSX 구문을 좀 더 읽기 쉽게 만들기 위해 제공)이다.
                * `JSXFragment`: 값으로 별도 속성을 갖지 않는 형태의 JSX 요소가 들어갈 수 있다. 즉, 비어 있는 형태의 <></>가 허용된다.
    * JSXChildren
        * JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXCildren이라고 한다.
        
        * `JSXChild`: JSXChildren을 이루는 기본 단위다. JSXChildren은 JSXChild를 0개 이상 가질 수 있다.
            * `JSXText`: {,<,>,}을 제외한 문자열.
            * `JSXFragment`: 값으로 빈 JSX요소인 <></>가 들어갈 수 있다.
            * `{ JSXChildExpression (optional) }`: 이 JSXChildExpression은 자바스크립트의 **AssignmentExpression(화살표 함수)**을 의미한다.
                ```javascript
                // 이 함수를 리액트에서 렌더링하면 'foo'라는 문자열이 출력됨.
                export default function App() {
                    return <>{(() => 'foo')()}</>
                }
                ```

    * JSXStrings
        * JSXAttributeValue와 JSText는 HTML과 JSX사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계되어 있다. HTML에서 사용 가능한 문자열은 모두 JSXString에서도 가능하다. → 개발자가 HTML 내용을 손쉽게 JSX로 가져올 수 있도록 의도적으로 설계된 부분임
            * 여기서 정의된 문자열은 "큰따옴표로 구성된 문자열", '작은 따옴표로 구성된 문자열' 혹은 JSXText를 의미함.
            * 자바스크립트와 한 가지 중요한 차이점
                * \로 시작하는 이스케이프 문자 형태소다. \는 자바스크립트에서 특수문자를 처리할 때 사용되므로 몇 가지 제약 사항(\를 표현하기 위해서 \\\로 이스케이프해야 함)이 있지만 HTML에서는 아무런 제약 없이 사용할 수 있다.

### JSX 예제
```javascript
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕하세요</A>

// 자식이 없이 SelfClosingTag로 닫혀 있는 형태도 가능하다.
const ComponentB = <A />

// 옵션을 {}와 전개 연산자로 넣을 수 있다.
const ComponentC = <A {...{ required: true}} />

// 속성만 넣어도 가능하다.
const ComponentD = <A required />

// 속성과 속성을 넣을 수 있다.
const ComponentE = <A required={false} />

const ComponentF = (
    <A>
        {/* 문자열은 큰따옴표 및 작은따옴표 모두 가능하다. */}
        <B text="리액트" />
    </A>
)

const ComponentG = (
    <A>
        {/* 옵션의 값으로 JSXElement를 넣는 것 또한 올바른 문법이다.*/}
        <B optionalChildren={<>안녕하세요.</>} />
    </A>
)

const ComponentH = (
    <A>
        {/* 여러 개의 자식도 포함할 수 있다. */}
        안녕하세요
        <a text="리액트" />
    </A>
)
```
### JSX는 어떻게 자바스크립트에서 변환될까?
JSX가 자바스크립트로 어떻게 변환되는지 알아야 하는 이유는 **중복 코드를 최소화할 수 있기에 유용하기 때문**이다. 그럼 어떻게 변환하는지 살펴보자.

* 우선 자바스크립트에서 JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 Babel(@babel/plugin-transform-react-jsx 플러그인)을 알아야 한다. (JSX 구문 → 자바스크립트가 이해할 수 있는 형태로 변환)

* 예시
    * JSX 코드
        ```javascript
        const ComponentA = <A required={true}>Hello World</A>
        
        const ComponentB = <>Hello World</>

        const ComponentC = (
            <div>
                <span>hello world</span>
            </div>
        )
        ```
    * 리액트 17, 바밸 7.9.0 이전 버전에서 변환한 결과를 보면
    * JSX 코드를 Babel(@babel/plugin-transform-react-jsx)로 변환한 결과
        ```javascript
        'use strict'

        var ComponentA = React.createElement(
            A, 
            {
            required: true,
            },
            'Hello World',
        )
        var ComponentB = React.createElement(React.Fragment, null, 'Hello World')
        var CompoentC = React.createElement(
            'div',
            null,
            React.createElement('span', null, 'hello world'),
        )
        ```
        * JSXElement를 첫 번째 인수로 선언해 요소를 정의함 (태그 이름, 컴포넌트)
        * 옵셔널인 JSXAttributes, JSXChildren, JSXString는 이후 인수로 넘겨주어 처리한다.

        따라서 이 변환하는 과정을 봤을 때 **트랜스파일러인 Babel은 이러한 JSX로 작성된 코드를 React.createElement 호출로 변환하는 것**을 알 수 있다. 결국 JSX가 React.createElement와 동일한 역할을 한다고 볼 수 있다.

        이 점을 활용한다면 앞서 말했듯이 경우에 따라 다른 JSXElement를 렌더링 해야할 때 요소 전체를 감싸지 않더라도 처리할 수 있다.
        ```javascript
        // props 여부에 따라 children 요소만 달라지는 경우
        function TextOrHeading({
            isHeading,
            children,
        }: PropsWithChildren<{ isHeading: boolean }>) {
            return isHeading ? (
                <h1 className = "text">{children}</h1>
            ) : (
                <span className = "text">{children}></span>
            )
        }

        // JSX가 변환되는 특성을 활용한다면 간결하게 처리할 수 있다.
        import {createElement} from 'react'

        function TextOrHeading({
            isHeading,
            children,
        }: PropsWithChildren<{ isHeading: boolean }>) {
            return createElement(
                isHeading ? 'h1' : 'span',
                { className: 'text' },
                children,
            )
        }
        ```
        * 대부분의 경우에는 JSX를 사용하는 것이 가독성과 유지 보수 측면에서 더 좋다.
        * 특정 상황(일반적이지 않은 경우, 동적으로 요소를 생성해야 하는 특수한 경우)에서만 React.Element를 직접 사용하여 동적인 요소를 생성하는 것이 더 나은 방법일 수 있다.

### 정리
* JSX 문법에는 있지만 실제로 리액트에서 사용하지 않는 JSXNamespaceName, JSXMemberExpression가 있으며, 이는 React가 아닌 Preact, SolidJS 등 다양한 라이브러리도 JSX를 채용하여 리액트와는 다르게 목적에 따라 사용할 수 있어 알고 있어야 하는 문법이다.

* JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있다. but, JSX가 HTML 문법과 자바스크립트 문법이 뒤섞여서 코드의 가독성을 해친다는 의견도 있다.

* 그래도 현재 많이 사용되는 것으로 파악되고 있으며 리액트 내부에서 JSX가 어떻게 변환하는지 원리를 알고 있으면 컴포넌트 구성에 더 효율적일 수 있다.
