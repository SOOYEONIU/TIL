# 리액트 핵심 요소 깊게 살펴보기

## JSX란?
* 보통 리액트를 통해 JSX를 접하기 때문에 JSX가 리액트의 전유물이라고 오해하는 경우가 있다. → 반은 맞고 반은 틀림

* JSX는 흔히 개발자들이 알고 있는 XML과 구조적으로 유사한 내장형 구문이며(구조적으로 비슷해보이지만 각각의 용도와 사용 환경은 다름), 리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 옳다.

* 페이스북에서 독자적으로 개발했기에 자바스크립트 표준의 일부는 아니다. 따라서 JSX가 포함된 코드는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환된다. 

* JSX의 설계 목적
    * 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는데 초점을 두고 있다.
    * 쉽게 이야기 하면, **JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해두고, 이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경하는 것이 목표라 볼 수 있다.**

### JSX의 정의
* JSX의 4가지 기본 컴포넌트 구성
    * `JSXElement`
        * JSX를 구성하는 가장 기본적인 요소, HTML의 요소(element)와 비슷한 역할을 함.
        * 형태
            * `JSXOpeningElement`, `JSXClosingElement`
                * 두 요소는 일반적인 HTML 태그와 같은 형태로 사용된다. 따라서 반드시 쌍으로 사용되어야 한다.
                * 사용 상황:
                    * 여러 자식을 포함하는 경우 : 태그 내부에 다른 태그나 텍스트를 포함하여 구조를 잡을 때 사용
                    * 상태나 props에 따라 내용이 동적으로 변할 때: 렌더될 내용을 조건에 따라 다르게 보여주고 싶을떄 사용
                ```javascript
                const MyComponent = (props) => {
                    return (
                    <div>
                    <h1>안녕하세요, {props.name}</h1>
                    <p>React JSX 예시입니다.</p>
                    </div>
                    );
                };

                export default function App() {
                    return ( 
                    <MyComponent name={"sooyeon"}>
                    </MyComponent>
                    );
                }
                ```
                * 위 예제에서 보이는 \<MyComponent>와 \</MyComponent>가 JSXOpeningElement와 JSXClosingElement로 이루어져 있다.
            * `JSXSelfClosingElement`
                * 요소가 시작되고, 스스로 종료되는 형태를 의미한다. 자식 요소가 없는 경우 사용된다.
                * 이는 HTML의 단일 태그(\<img />, \<input /> 등)와 유사하다.
            * `JSXFragment`
                * 아무런 요소가 없으며 반환되는 요소가 여러개인 경우 여러 요소를 그룹화할 때 사용된다. 
                * ReactFragment는 <React.Fragment></React.Fragment> 또는 간단한 단축 문법인 <></>를 사용하여 작성할 수 있다.
        * 이러한 요소들을 활용하여 더 유지보수 가능하고 읽기 쉬운 코드를 작성하는데 도움을 준다.

        * 리액트에서 컴포넌트를 만들어 사용할 때는 반드시 대문자로 시작하는 컴포넌트를 만들어야 사용 가능하다. 이유는 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서다.
        
        * `JSXElementName` : 요소 이름을 짓는 원칙이 있다. 그 원칙을 함께 살펴보자.
            * `JSXIdentifier` : JSX 내부에서 사용할 수 있는 식별자를 의미한다. 그리고 자바스크립트와 마찬가지로 숫자로 시작하거나 $와 _외의 다른 특수문자로는 시작할 수 없다.
                ```javascript
                <Component />
                ```
                * 장점 : 읽기 쉽고 간단하며, 대부분의 일반적인 컴포넌트 사용 사례에 적합하다.
            
            * `JSXNamespacedName`: `JSXIdentifier:JSXIdentifier`의 조합
                * 즉 :을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. :로 묶을 수 있는 것은 한 개뿐이다.
                * JSX 구문에서 네임스페이스 접두사가 있는 이름을 나타내기 위한 용어이다.
                    ```Javascript
                    <namespace:Component />
                    ```
                * JSX에서는 대부분의 네임스페이스 관련 작업이 자동으로 처리되어 개발자가 명시적으로 `JSXNamespaceName`을 명시하는 경우는 드물다.

            * `JSXMemberExperssion`: `JSXIdentifier.JSXIdentifier`의 조합
                * 즉 .을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. .는 여러 개 이어서 하는 것도 가능하다. 단, JSXNamespacedName과 이어서 사용하는 것은 불가능하다.
                    ```javascript
                    const MyComponents = {
                        DatePicker: function DataPicker(props) {
                            return <div>{props.date}</div>
                        }
                    };

                    function App() {
                        return(
                            <div>
                                <MyComponents.DatePicker date={new Date().toLocaleDateString()}>
                            </div>
                        )
                    }
                    ```
                * 위 코드에서 <MyComponents.DatePicker />는 JSXMemberExpression의 예시이다. 이 표현식은 MyComponents 객체의 DatePicker 속성을 참조한다.
                * React에서 JSXMemberExpression은 내부적으로 중요한 역할을 하지만, 개발자가 이를 다루거나 언급할 필요 없다. **React와 Babel등의 도구는 이러한 내부적인 복합성을 자동으로 처리하여 개발자가 더 생산적으로 작업할 수 있도록 돕는다.**

    * JSXAttributes
        * JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않는다.

            * JSXSpreadAttributes: 자바스크립트의 전개 연산자(스프레드 연산자)와 동일한 역할을 한다고 볼 수 있다. 따라서, 스프레드 연산자를 사용해 여러 속성을 한번에 추가할 때 사용한다. 
                * {...AssignmentExpression}: 이 AssignmentExpression에는 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있다. 여기에 조건문 표현식, 화살표 함수, 할당식 등 다양한 것이 포함되어 있다.
                * 아래의 예시로 이해를 돕는다.
                ```javascript
                import React from 'react';

                const Button = (props) => {
                    return <button {...props}>{props.label}</button>;
                }

                const App = () => {
                    const buttonProps = {
                        type: 'button',
                        onClick: () => alert('Button Clicked'),
                        style: {backgroundColor: 'blue', color: 'white'},
                        label: 'Click me',
                    }

                    return {
                        <div>
                            <h1>JSXSpreadAttributes Example</h1>
                            <Button {...buttonProps}>
                        </div>
                    }
                }

                export default App;
                ```
                이렇게 하면 각 속성을 하나씩 전달하는 대신 간편하게 한번에 전달할 수 있어서 코드가 더 깔끔해지고 유지보수하기 쉬워진다. 

            * JSXAttributeValue: 속성의 키에 할당할 수 있는 값으로, 다음 중 하나를 만족해야 한다.
                * `"큰따옴표로 구성된 문자열"`: 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
                * `'작은따옴표로 구성된 문자열'`: 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
                * `{ AssignmentExpression }`: 자바스크립트의 AssignmentExpression을 의미한다. AssignmentExpression은 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말한다. 즉, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능하다.
                * `JSXElement`: 값으로 다른 JSX 요소가 들어갈 수 있다. 리액트에선 자주 보이진 않는 코드이다.
                * \<Child attribute=\{\<div>hello\</div>\} />와 같이 값으로 들어가는 리액트 컴포넌트를 {}로 감싸는 걸 보는 것이 더 익숙할텐데, 사실 이것은 문법적 오류가 아닌 prettier의 규칙(태그가 포함된 JSX 구문을 좀 더 읽기 쉽게 만들기 위해 제공)이다.
                * `JSXFragment`: 값으로 별도 속성을 갖지 않는 형태의 JSX 요소가 들어갈 수 있다. 즉, 비어 있는 형태의 <></>가 허용된다.
    * JSXChildren
        * JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXCildren이라고 한다.
        
        * `JSXChild`: JSXChildren을 이루는 기본 단위다. JSXChildren은 JSXChild를 0개 이상 가질 수 있다.
            * `JSXText`: {,<,>,}을 제외한 문자열.
            * `JSXFragment`: 값으로 빈 JSX요소인 <></>가 들어갈 수 있다.
            * `{ JSXChildExpression (optional) }`: 이 JSXChildExpression은 자바스크립트의 **AssignmentExpression(화살표 함수)**을 의미한다.
                ```javascript
                // 이 함수를 리액트에서 렌더링하면 'foo'라는 문자열이 출력됨.
                export default function App() {
                    return <>{(() => 'foo')()}</>
                }
                ```

    * JSXStrings
        * JSXAttributeValue와 JSText는 HTML과 JSX사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계되어 있다. HTML에서 사용 가능한 문자열은 모두 JSXString에서도 가능하다. → 개발자가 HTML 내용을 손쉽게 JSX로 가져올 수 있도록 의도적으로 설계된 부분임
            * 여기서 정의된 문자열은 "큰따옴표로 구성된 문자열", '작은 따옴표로 구성된 문자열' 혹은 JSXText를 의미함.
            * 자바스크립트와 한 가지 중요한 차이점
                * \로 시작하는 이스케이프 문자 형태소다. \는 자바스크립트에서 특수문자를 처리할 때 사용되므로 몇 가지 제약 사항(\를 표현하기 위해서 \\\로 이스케이프해야 함)이 있지만 HTML에서는 아무런 제약 없이 사용할 수 있다.

### JSX 예제
```javascript
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕하세요</A>

// 자식이 없이 SelfClosingTag로 닫혀 있는 형태도 가능하다.
const ComponentB = <A />

// 옵션을 {}와 전개 연산자로 넣을 수 있다.
const ComponentC = <A {...{ required: true}} />

// 속성만 넣어도 가능하다.
const ComponentD = <A required />

// 속성과 속성을 넣을 수 있다.
const ComponentE = <A required={false} />

const ComponentF = (
    <A>
        {/* 문자열은 큰따옴표 및 작은따옴표 모두 가능하다. */}
        <B text="리액트" />
    </A>
)

const ComponentG = (
    <A>
        {/* 옵션의 값으로 JSXElement를 넣는 것 또한 올바른 문법이다.*/}
        <B optionalChildren={<>안녕하세요.</>} />
    </A>
)

const ComponentH = (
    <A>
        {/* 여러 개의 자식도 포함할 수 있다. */}
        안녕하세요
        <a text="리액트" />
    </A>
)
```
### JSX는 어떻게 자바스크립트에서 변환될까?
JSX가 자바스크립트로 어떻게 변환되는지 알아야 하는 이유는 **중복 코드를 최소화할 수 있기에 유용하기 때문**이다. 그럼 어떻게 변환하는지 살펴보자.

* 우선 자바스크립트에서 JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 Babel(@babel/plugin-transform-react-jsx 플러그인)을 알아야 한다. (JSX 구문 → 자바스크립트가 이해할 수 있는 형태로 변환)

* 예시
    * JSX 코드
        ```javascript
        const ComponentA = <A required={true}>Hello World</A>
        
        const ComponentB = <>Hello World</>

        const ComponentC = (
            <div>
                <span>hello world</span>
            </div>
        )
        ```
    * 리액트 17, 바밸 7.9.0 이전 버전에서 변환한 결과를 보면
    * JSX 코드를 Babel(@babel/plugin-transform-react-jsx)로 변환한 결과
        ```javascript
        'use strict'

        var ComponentA = React.createElement(
            A, 
            {
            required: true,
            },
            'Hello World',
        )
        var ComponentB = React.createElement(React.Fragment, null, 'Hello World')
        var CompoentC = React.createElement(
            'div',
            null,
            React.createElement('span', null, 'hello world'),
        )
        ```
        * JSXElement를 첫 번째 인수로 선언해 요소를 정의함 (태그 이름, 컴포넌트)
        * 옵셔널인 JSXAttributes, JSXChildren, JSXString는 이후 인수로 넘겨주어 처리한다.

        따라서 이 변환하는 과정을 봤을 때 **트랜스파일러인 Babel은 이러한 JSX로 작성된 코드를 React.createElement 호출로 변환하는 것**을 알 수 있다. 결국 JSX가 React.createElement와 동일한 역할을 한다고 볼 수 있다.

        이 점을 활용한다면 앞서 말했듯이 경우에 따라 다른 JSXElement를 렌더링 해야할 때 요소 전체를 감싸지 않더라도 처리할 수 있다.
        ```javascript
        // props 여부에 따라 children 요소만 달라지는 경우
        function TextOrHeading({
            isHeading,
            children,
        }: PropsWithChildren<{ isHeading: boolean }>) {
            return isHeading ? (
                <h1 className = "text">{children}</h1>
            ) : (
                <span className = "text">{children}></span>
            )
        }

        // JSX가 변환되는 특성을 활용한다면 간결하게 처리할 수 있다.
        import {createElement} from 'react'

        function TextOrHeading({
            isHeading,
            children,
        }: PropsWithChildren<{ isHeading: boolean }>) {
            return createElement(
                isHeading ? 'h1' : 'span',
                { className: 'text' },
                children,
            )
        }
        ```
        * 대부분의 경우에는 JSX를 사용하는 것이 가독성과 유지 보수 측면에서 더 좋다.
        * 특정 상황(일반적이지 않은 경우, 동적으로 요소를 생성해야 하는 특수한 경우)에서만 React.Element를 직접 사용하여 동적인 요소를 생성하는 것이 더 나은 방법일 수 있다.

### 정리
* JSX 문법에는 있지만 실제로 **리액트에서 자동으로 처리하여 사용하지 않는** `JSXNamespaceName`, `JSXMemberExpression`가 있으며, 이는 React가 아닌 Preact, SolidJS 등 다양한 라이브러리도 JSX를 채용하여 리액트와는 다르게 목적에 따라 사용할 수 있어 알고 있어야 하는 문법이다.

* JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있다. but, JSX가 HTML 문법과 자바스크립트 문법이 뒤섞여서 코드의 가독성을 해친다는 의견도 있다.

* 그래도 현재 많이 사용되는 것으로 파악되고 있으며 리액트 내부에서 JSX가 어떻게 변환하는지 원리를 알고 있으면 컴포넌트 구성에 더 효율적일 수 있다.

## 가상 DOM과 리액트 파이버
### DOM과 브라우저 렌더링 과정
* DOM(Documnet Object Mdoel, 문서 객체 모델)이란?
    * 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다. 브라우저 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는 것
    * 브라우저가 HTML 웹 페이지를 인식하는 방식을 **계층화**(순서에 따라 우선순위를 부여)시켜 **트리구조**로 만든 객체(Object)모델
    * 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정
        1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다.
        2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
        3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
        4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
        5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 
        6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다.
            * DOM 노드에 CSS를 적용하는 방법
                * `레이아웃(layout, reflow)` : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면서 반드시 페인트 과정도 거치게 된다.
                * `페인팅(painting)`: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

    * 예시코드를 살펴보자
        ```html
        #text {
            background-color: read;
            color: white;
        }
        <!DOCTYPE html>
        <html>
            <head>
                <link rel="stylesheet" type="text/css" href="./style.css" />
                <title>Hello React!</title>
            </head>
            <body>
                <div style="width: 100%;">
                    <div id="text" style="width: 50%;">Hello world!</div>
                </div>
            </body>
        </html>
        </html>
        ```

        1. HTML을 다운로드한다. 다운로드와 함께 HTML을 분석하기 시작
        2. 스타일시트가 포함된 link 태그를 발견해 style.css를 다운로드
        3. body 태그 하단의 div는 width: 100%이므로 뷰포트(브라우저가 사용자에게 노출하는 영역)로 좌우 100% 너비로 잡는다.
        4. 3번 하단의 div는 width: 50%, 즉 부모 50%를 너비로 잡아야 하므로 전체 영역의 50%를 너비로 잡는다.
        5. 2번에서 다운로드에 CSS에 id="text"에 대한 스타일 정보를 결합한다.
        6. 화면에 HTML 정보를 그리기 위한 모든 정보가 준비되었으므로 위 정보를 바탕으로 렌더링을 수행한다. 
    
    브라우저는 이러한 과정을 거쳐 웹 페이지를 렌더링 한다. 이제 DOM의 기본 원리를 알아보았으니 가상 DOM에 대해 알아보자.

### 가상 DOM의 탄생 배경
#### 실제 DOM 조작 문제점
* 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. 그리고 렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황도 고려해야 한다. 
* 여기에 만약 DOM 변경이 일어나는 요소가 자식 요소를 가지고 있는 경우에는 하위 자식 요소도 덩달아 변경돼야 하기 때문에 더 많은 비용을 브라우저와 사용자까지 지불해야하는 문제점이 발생한다.

#### 가상 DOM의 탄생 배경
* 가상 DOM(Virtual DOM)은 실제 DOM의 조작이 느리고 비효율적이기 때문에 이를 개선하여 성능을 향상시키려는 목적에서 비롯되었다.

* 대표적으로 React가 가상 DOM을 활용하여 효율적인 상태 업데이트와 성능 최적화를 이뤄낸 예가 있다. React는 데이터 변경이 발생할 때마다 메모리상에 새로운 가상 DOM을 생성하고, 이전 상태와 비교한 뒤, 필요한 부분만 실제 DOM에 업데이트하는 원리이다. → 빠르고 반응성이 뛰어나다.

* 즉, DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 되어 실제로는 여러 번 발생했을 렌더링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 줄여준다. → 성능문제 해결

* but, 가상 DOM이 많은 상황에서 성능 개선을 제공할 수 있지만, 무조건적인 해결책은 아니다. 애플리케이션의 특성, 규모, 주요 사용자 상호작용 패턴 등을 종합적으로 고려해야 한다. 예를 들어 변경이 자주 일어나는 애플리케이션일 경우 성능 개선이 있는 것이다.

### 가상 DOM을 위한 아키텍처, 리액트 파이버
* 가상 DOM을 만드는 과정을 리액트는 어떻게 처리하고 있을까? 리액트는 여러 번의 렌더링 과정을 압축해 어떻게 최소한의 렌더링 단위를 만들어 내는 것일까? → 가상 DOM과 렌더링 최적화를 가능하게 해주는 것 : `리액트 파이버(React Fiber)`

#### 리액트 파이버(React Fiber)란?
* 리액트 파이버는 리액트에서 관리하는 평범한 **자바스크립트 객체**다.
* 파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가직 욌는 파이버를 기준으로 화면에 렌더링을 요청하는 역할이다.
    * 재조정(reconciliation)이란
        * 이랙트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업 (= diff 알고리즘)이라고 이해하면 된다.

* 파이버가 할 수 있는 일 ( 비동기적 )
    * 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매김
    * 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
    * 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.

**파이버의 등장, 파이퍼 이전 스택 알고리즘**
* 과거 리액트의 조정 알고리즘은 스택 알고리즘으로 이뤄져 있었다. 이는 동기적인 작업을 뜻하며 자바스크립트의 특징인 싱글 스퍼드라는 점으로 인해 동기 작업은 중단될 수 없고, 다른 작업이 수행되고 싶어도 중단할 수 없었다. → 비효율성
* 기존 렌더링 스택의 비효율성을 타파하기 위해 리액트 팀은 파이퍼라는 개념을 탄생시킨 것!

**그렇다면, 파이퍼는 어떻게 구현되어 있을까?**
* 파이퍼는 하나의 작업 단위로 구성되어 있다. 리액트에서 이 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.
    * 2단계
        1. **렌더 단계**에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어남
        2. **커밋 단계**에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWokr()가 실행되는데, 이는 동기식으로 일어나고 중단될 수 도 없다.

* **리액트 내부 코드에 작성돼 있는 파이버 객체**(134p)를 보면 파이버가 단순한 자바스크립트 객체로 구성되어 있는 것을 볼 수 있다.
    * 파이버는 리액트 요소와 비슷하지만 한 가지 중요한 차이점이 있다. 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다는 사실이다. 즉, **파이퍼는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.**

* **리액트에 작성돼 있는 파이퍼를 생성하는 다양한 함수**의 코드를 보면 **파이퍼는 하나의 element에 하나가 생성되는 1:1관계를 가지고 있는 것**을 알 수 있다. (여기서 1:1로 매칭된 정보를 가지고 있는 것은 tag이다. 1:1로 연결되는 것은 리액트의 컴포넌트, HTML의 DOM 노드 등이 있다.)

* **리액트에 작성돼 있는 파이버의 태그가 가질 수 있는 값**들 코드를 보면, 리액트 컴포넌트 트리가 형성되는 것과 동일하게 파이버도 트리 형식을 갖는 것을 알 수 있다. 한 가지 리액트 컴포넌트와 다른 점은 children이 없고 child만 존재한다는 점이다.
    * <details>
        <summary>그럼 여러개의 자식이 있는 구조는 파이버로 어떻게 표현될까?</summary>
        
        ```html
        <ul>
            <li>하나</li>
            <li>둘</li>
            <li>셋</li>
        </ul>
        ```
        * 자식은 항상 첫 번째 자식의 참조로 구성되어 \<ul> 파이버의 자식은 첫 번째 \<li/> 파이버가 된다. 나머지 두개의 \<li/>파이버는 형제, 즉 sibling으로 구성된다.

        ```javascript
        const 13 = {
            return : ul,
            index : 2,
        }

        const 12 = {
            sibling: l3,
            return: ul,
            index: 1,
        }

        const 11 = {
            sibling: l2,
            return: ul,
            index: 0,
        }

        const ul = {
            // ...
            child: li,
        }
        ```
        index: 여러 형제들(sibling) 사이에서 자신의 위치가 몇 번째인지 숫자로 표현한다. 
    </details>

**이 외**
* pendingProps : 아직 작업을 미처 처리하지 못한 props
* memorizedProps : pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps로 저장해 관리한다. 
* updateQueue : 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐이다.
* memoizedState : 함수형 컴포넌트의 훅 목록이 저장된다. 여기에는 단순히 useState뿐만 아니라 모든 훅 리스트가 저장된다.
* alternate : 뒤이어 설명할 리액트 파이버 트리와 이어질 개념. 리액트의 트리는 두 개인데, 이 alternate는 반대편 트리 파이버를 가리킨다.

이렇게 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다.

**리액트가 파이버를 처리할 때 마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다는 것이다.** 즉, 이런 작업들은 작은 단위로 나눠서 처리하거나 애니메이션과 같이 우선순위가 높은 작업은 가능한 빠르게 처리하거나, 낮은 작업은 연기시키는 등 유연한 처리 방법이 된다.

#### 리액트 파이버 트리
* 파이버 트리는 내부에서 두 개가 존재함
    1. 현재 모습을 담은 파이버 트리
    2. 작업 중인 상태를 나타내는 workInProgress 트리
* 리액트 피아버의 작업이 끝나면 리액트는 단순히 포인터만 workInProgress트리를 현재 트리로 변경한다. (이러한 기술을 `더블 버퍼링`이라 한다.)
    * `더블 버퍼링` : 컴퓨터 그래픽 분야 용어, 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법

* 리액트에서도 미처 다 그리지 못한 모습을 노출시키지 않기 위해(불완전한 트리를 보여주지 않기 위해) 더블 버퍼링 기법을 쓰는데, 이러한 더블 버퍼링을 위해 트리가 두 개 존재하며, 이 더블 버퍼링은 커밋 단계에서 수행된다.
![alt text](image.png)

#### 파이버의 작업 순서
1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그 다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번, 3번 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다. (→ 최종적으로 commitWork()가 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영되는 것)

이 과정을 통해 트리가 생성되었다.

이제 여기서 setState 등으로 업데이터가 발생하면 앞서 만든 current 트리가 존재하고, setState로 인한 업데이트 요청을 받아 workInProgress 트리를 다시 빌드하기 시작한다. 

* 이 빌드 과정은 앞서 트리를 만드는 과정과 동일하다.

최조 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만 이제는 파이버가 이미 존재하여 되도록 새로 생성지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.

따라서 일반적으로 리액트 애플리케이션은 이렇게 트리를 비교해서 업데이트하는 작업이 시도때도 없이 일어난다. 따라서 **반복적인 재조정 작업 때마다 새롭게 파이버 자바스크립트 객체를 만드는 것이 리소스 낭비**라 볼 수 있다. 가급적 객체를 새롭게 만들기보다는 기존에 있는 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트하여 성능 향상에 도움을 준다.

### 파이버와 가상 DOM
리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이고, 이 파이버는 **리액트 아키텍처 내부에서 비동기**로 이뤄진다.

이러한 비동기 작업과 달리, 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높아 **메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것**이다. → 가상 DOM

### 정리
지금까지 리액트에서 가상 DOM의 개념과 가상 DOM을 구현하기 위해 만들어진 리액트 파이버의 개념과 이를 조정하는 재조정자에 대해 알아봤다.

개발자가 직접 DOM을 수동으로 변경해야 한다면 어떤 값이 바뀌었는지, 또 그 값에 따라 어떠한 값이 변경됐고 이와 관련된 것들이 무엇인지 파악해야 한다. 이 어려움을 리액트 내부의 파이버와 재조정자가 내부적인 알고리즘(diff 알고리즘)을 통해 관리해 줌으로써 대규모 웹 애플리케이션을 효율적으로 유지보수하고 관리할 수 있다.

이는 즉 가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현한 것이다. 
